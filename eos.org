#+TITLE: The Emacs Operating System (EOS)
#+PROPERTY: header-args:emacs-lisp :tangle yes
#+PROPERTY: header-args:sh :eval no

* Emacs Operating System
People call it that, so let's prove them right. More documentation is
forthcoming, but this is my tribute to the [[http://doc.rix.si/cce/cce.html][Complete Computing Environment]].

* How to use these files

So usually you would check out [[https://github.com/dakrone/eos/][this repository]] and then run =make= in the
directory. That will tangle a bunch of =.el= files. If you want to install this,
run =make install= (or just =make init= if you only want to run initialization
things).

Once it's installed, make changes to the files directly and then just run =make=
to re-tangle the files, no re-installation necessary, since symlinks are set up
the first time you ran =make install=.

* Initial Preparation
We need to prepare the system for running EOS, so we need to tangle an
initialization script and invoke it. This is handled by the =Makefile= which
special-cases this one file.

#+BEGIN_SRC sh :tangle initialize.sh
# Directory for user-installed scripts
mkdir -p ~/bin

# GnuPG
mkdir -p ~/.gnupg
chmod 700 ~/.gnupg

# SSH
mkdir -p ~/.ssh
chmod 700 ~/.ssh

# Emacs configuration folders
mkdir -p ~/.emacs.d
mkdir -p ~/.emacs.d/snippets
mkdir -p ~/.emacs.d/eshell
#+END_SRC

** Installation script
In addition to the prep script, there needs to be a script used for
installation that actually links up the appropriate parts.

Warning! This will overwrite your current configuration!

#+BEGIN_SRC sh :tangle install.sh :eval no
ln -sfv $PWD/eos.el ~/.emacs.d/init.el
ln -sfv $PWD ~/.emacs.d/eos
cp -vf bin/* ~/bin
#+END_SRC

* The EOS Module Set
There is of course the prerequisite, which is this file, and then the EOS
contains a number of different configurations and modules. This is a basic
overview of the modules, which you should visit should you desire more
information about a particular module.

Ideally, each module except for the "Core" module is optional and can be skipped
if not desired.

- [[./eos-core.org][Core Computing System]]
- [[./eos-appearance.org][Appearance]]
- [[./eos-navigation.org][Navigation]]
- [[./eos-notify.org][Notification System]]
- [[./eos-helm.org][Helm]]
- [[./eos-develop.org][Development (programming) System]]
  - [[./eos-java.org][Java]]
  - [[./eos-clojure.org][Clojure]]
  - [[./eos-es.org][Elasticsearch]]
- [[./eos-org.org][Org-mode and agenda]]
- [[./eos-writing.org][Writing]]
- [[./eos-dired.org][Dired]]
- [[./eos-remote.org][Working with Remote Servers]]
- [[./eos-web.org][Web browsing]]
- [[./eos-shell.org][Shell]]
- [[./eos-mail.org][Mail (Email)]]
- [[./eos-irc.org][IRC]]
- [[./eos-rss.org][RSS]]
- [[./eos-twitter.org][Twitter]]
- [[./eos-leisure.org][Fun and Leisure]]
- [[./eos-music.org][Music]]

* =init.el=

#+BEGIN_SRC emacs-lisp
;; Load a custom version of cedet, if available
(when (file-exists-p "~/src/elisp/cedet/cedet-devel-load.el")
  (load "~/src/elisp/cedet/cedet-devel-load.el"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; Load a custom version of org-mode, if available
(when (file-exists-p "~/src/elisp/org-mode/lisp")
  (add-to-list 'load-path "~/src/elisp/org-mode/lisp")
  (require 'org))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq debug-on-error t)
(setq debug-on-quit t)
#+END_SRC

Also, let's make =cl= things available right from the start

#+BEGIN_SRC emacs-lisp
(require 'cl)
#+END_SRC

I can't live without this, "x" on Dvorak is where "b" is on Qwerty, and it's
just too hard for all the C-x things I have to hit. Maybe one day I'll just
switch to evil (or god-mode) and be done with it.

For now, 't' is much more convenient so I switch =C-x= and =C-t= on the
keyboard. I don't transpose things nearly as often as I =C-x= things

#+BEGIN_SRC emacs-lisp
(define-key key-translation-map "\C-t" "\C-x")
(define-key key-translation-map "\C-x" "\C-t")
#+END_SRC

** =package.el= Setup
My strategy with regard to packaging is simple, I make heavy use of use-package.

#+BEGIN_SRC emacs-lisp
(require 'package)
(package-initialize)

(add-to-list 'package-archives
             '("org" . "http://orgmode.org/elpa/") t)
(add-to-list 'package-archives
             '("gnu" . "http://elpa.gnu.org/packages/") t)
(add-to-list 'package-archives
             '("melpa-stable" . "http://stable.melpa.org/packages/") t)
(add-to-list 'package-archives
             '("melpa" . "http://melpa.org/packages/") t)
#+END_SRC

Let's also set up a custom file and load it before we do anything too fancy, we
want to make sure to keep customize settings in their own file instead of
init.el.

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

I define =eos/did-refresh-packages=, which is used as a signal in =install-pkgs=
that we need to refresh the package archives.

#+begin_src emacs-lisp
(defvar eos/did-refresh-packages nil
  "Flag for whether packages have been refreshed yet")
#+end_src

=install-pkgs= is a simple elisp function that will iterate over a list, and
install each package in it, if it is not installed. If
=eos/did-refresh-packages= is set to =nil=, it'll also refresh the package
manager.

#+begin_src emacs-lisp
(defun install-pkgs (list)
  (dolist (pkg list)
    (progn
      (if (not (package-installed-p pkg))
          (progn
            (if (not eos/did-refresh-packages)
                (progn (package-refresh-contents)
                       (setq eos/did-refresh-packages t)))
            (package-install pkg))))))
#+end_src

Pin some of the packages that go wonky if I use the bleeding edge.

#+BEGIN_SRC emacs-lisp
(when (boundp 'package-pinned-packages)
  (setq package-pinned-packages
        '((org-plus-contrib                  . "org")
          (cider                             . "melpa-stable")
          (ac-cider                          . "melpa-stable")
          (clojure-mode                      . "melpa-stable")
          (clojure-mode-extra-font-locking   . "melpa-stable")
          (company-cider                     . "melpa-stable"))))
#+END_SRC

Now, install the things we need in the future for all other package
installation/configuration

#+BEGIN_SRC emacs-lisp
(install-pkgs '(use-package))
;; Load use-package, used for loading packages everywhere else
(require 'use-package nil t)
;; Set to t to debug package loading or nil to disable
(setq use-package-verbose nil)
#+END_SRC

** =el-get= setup

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/el-get/el-get")

(unless (require 'el-get nil 'noerror)
  (with-current-buffer
      (url-retrieve-synchronously
       "https://raw.githubusercontent.com/dimitri/el-get/master/el-get-install.el")
    (goto-char (point-max))
    (eval-print-last-sexp)))

(add-to-list 'el-get-recipe-path "~/.emacs.d/el-get-user/recipes")
;;(el-get 'sync)
#+END_SRC

** Module setup

And now, let's start things up.

#+BEGIN_SRC emacs-lisp
(defvar after-eos-hook nil
  "Hooks to run after all of the EOS has been loaded")

(defvar emacs-start-time (current-time)
  "Time Emacs was started.")

;; Installed by `make install`
(add-to-list 'load-path "~/.emacs.d/eos/")

;; The EOS modules
(require 'eos-core)
(require 'eos-helm)
(require 'eos-appearance)
(require 'eos-navigation)
(require 'eos-notify)
(require 'eos-develop)
(require 'eos-es)
(require 'eos-org)
(require 'eos-writing)
(require 'eos-dired)
(require 'eos-remote)
(require 'eos-java)
(require 'eos-clojure)
(require 'eos-web)
(require 'eos-shell)
(require 'eos-mail)
(require 'eos-irc)
(require 'eos-rss)
(require 'eos-twitter)
(require 'eos-leisure)
(require 'eos-music)

;; Hooks
(add-hook 'after-eos-hook
          (lambda ()
            (message "The Emacs Operating System has been loaded")))

(defun eos/time-since-start ()
  (float-time (time-subtract (current-time)
                             emacs-start-time)))

(add-hook 'after-eos-hook
          `(lambda ()
             (let ((elapsed (eos/time-since-start)))
               (message "Loading %s...done (%.3fs)"
                        ,load-file-name elapsed))) t)
(add-hook 'after-init-hook
          `(lambda ()
             (let ((elapsed (eos/time-since-start)))
               (message "Loading %s...done (%.3fs) [after-init]"
                        ,load-file-name elapsed))) t)
(run-hooks 'after-eos-hook)
#+END_SRC

Turn debugging back off, if there were no errors then things successfully got loaded.

#+BEGIN_SRC emacs-lisp
(setq debug-on-error nil)
(setq debug-on-quit nil)
#+END_SRC
