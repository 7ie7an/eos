#+TITLE: EOS: Development Module
#+AUTHOR: Lee Hinman
#+EMAIL: lee@writequit.org
#+LANGUAGE: en
#+PROPERTY: header-args:emacs-lisp :tangle yes
#+PROPERTY: header-args:sh :eval no
#+HTML_HEAD: <link rel="stylesheet" href="https://dakrone.github.io/org2.css" type="text/css" />
#+EXPORT_EXCLUDE_TAGS: noexport
#+OPTIONS: H:4 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t
#+OPTIONS: skip:nil d:(HIDE) tags:not-in-toc
#+STARTUP: fold nodlcheck lognotestate content

#+BEGIN_SRC emacs-lisp
(provide 'eos-develop)
#+END_SRC

* EOS Development Module Configuration
:PROPERTIES:
:CUSTOM_ID: dev-module
:END:
Let's make .zsh also be a shell script

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.zsh$" . shell-script-mode))
#+END_SRC

This contains the configuration for elisp programming

Remove some back-ends from vc-mode, no need to check all these things, I use
=magit= for everything anyway:

#+BEGIN_SRC emacs-lisp
(setq vc-handled-backends '(git svn))
#+END_SRC

I need to hide the lighter for subword mode:

#+BEGIN_SRC emacs-lisp
(use-package subword
  :diminish subword-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package log4j-mode
  :ensure t
  :init
  (add-hook #'log4j-mode-hook #'view-mode)
  (add-hook #'log4j-mode-hook #'read-only-mode)
  (add-hook #'log4j-mode-hook #'hl-line-mode))
#+END_SRC

I have to hack something around this to make it fixed for org->html exports

#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :ensure t
  :init
  (add-hook 'prog-mode-hook #'fci-mode)
  :config
  ;; fix for org -> html export
  (defun fci-mode-override-advice (&rest args))
  (use-package org)
  (advice-add 'org-html-fontify-code :around
              (lambda (fun &rest args)
                (advice-add 'fci-mode :override #'fci-mode-override-advice)
                (let ((result  (apply fun args)))
                  (advice-remove 'fci-mode #'fci-mode-override-advice)
                  result)))

  (defvar eos/fci-disabled nil)
  (make-variable-buffer-local 'eos/fci-disabled)
  ;; Add a hook that disables fci if enabled when the window changes and it
  ;; isn't wide enough to display it.
  (defun eos/maybe-disable-fci ()
    (interactive)
    ;; Disable FCI if necessary
    (when (and fci-mode
               (< (window-width) (or fci-rule-column fill-column)))
      (fci-mode -1)
      (setq-local eos/fci-disabled t))
    ;; Enable FCI if necessary
    (when (and eos/fci-disabled
               (eq fci-mode nil)
               (> (window-width) (or fci-rule-column fill-column)))
      (fci-mode 1)
      (setq-local eos/fci-disabled nil)))

  (defun eos/add-fci-disabling-hook ()
    (interactive)
    (add-hook 'window-configuration-change-hook
              #'eos/maybe-disable-fci))
  (add-hook 'prog-mode-hook #'eos/add-fci-disabling-hook))
#+END_SRC

Highlight idle things, but only in certain modes

#+BEGIN_SRC emacs-lisp
(use-package idle-highlight-mode
  :ensure t
  :init
  (add-hook 'java-mode-hook #'idle-highlight-mode)
  (add-hook 'emacs-lisp-mode-hook #'idle-highlight-mode)
  (add-hook 'clojure-lisp-mode-hook #'idle-highlight-mode))
#+END_SRC

Hide-show is kind of like Vim's folding, but manually done right now.

I'm in the process of trying out [[https://github.com/gregsexton/origami.el][Origami]] as a replacement, since it's a bit
easier on the brain and has nicer functions (supposedly), however, Origami is
much slower than hideshow for large buffers.

#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :bind (("C-c TAB" . hs-toggle-hiding)
         ("C-\\" . hs-toggle-hiding)
         ("M-\\" . hs-hide-all)
         ("M-+" . hs-show-all))
  :init (add-hook #'prog-mode-hook #'hs-minor-mode)
  :diminish hs-minor-mode
  :config
  (defvar hs-special-modes-alist
    (mapcar 'purecopy
            '((c-mode "{" "}" "/[*/]" nil nil)
              (c++-mode "{" "}" "/[*/]" nil nil)
              (bibtex-mode ("@\\S(*\\(\\s(\\)" 1))
              (java-mode "{" "}" "/[*/]" nil nil)
              (js-mode "{" "}" "/[*/]" nil)
              (javascript-mode  "{" "}" "/[*/]" nil)))))
#+END_SRC

Uses =M-n= and =M-p= to jump between the same variable in multiple places

#+BEGIN_SRC emacs-lisp
(use-package smartscan
  :ensure t
  :init (add-hook #'prog-mode-hook #'smartscan-mode)
  :config
  (bind-key "M-'" #'other-window smartscan-map)
  (setq smartscan-symbol-selector "symbol"))
#+END_SRC

There is also some additional configuration that we may want to enable, let's do
that with additional highlighting modes.

First, highlight numbers in a "special" way, so they stick out:

#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
  :ensure t
  :init
  (add-hook 'prog-mode-hook #'highlight-numbers-mode))
#+END_SRC

Also highlight quoted symbols in a nice way.

#+BEGIN_SRC emacs-lisp
(use-package highlight-quoted
  :ensure t
  :init
  (add-hook 'prog-mode-hook #'highlight-quoted-mode))
#+END_SRC

Also highlight pre-defined symbols in elisp

#+BEGIN_SRC emacs-lisp
(use-package highlight-defined
  :ensure t
  :init
  (add-hook 'emacs-lisp-hook #'highlight-defined-mode))
#+END_SRC

Finally, let's highlight escape sequences in a better way also

#+BEGIN_SRC emacs-lisp
(use-package highlight-escape-sequences
  :ensure t
  :init
  (add-hook 'prog-mode-hook #'hes-mode))
#+END_SRC

** Semantic Editing
:PROPERTIES:
:CUSTOM_ID: semantic
:END:
First, use a development version of cedet if applicable, I download the latest
snapshot from http://www.randomsample.de/cedet-snapshots/ and extract it in
~/src/elisp. Don't forget to run =make= in it!

And then things to set up semantic mode

#+BEGIN_SRC emacs-lisp
(defun eos/setup-semantic-mode ()
  (interactive)
  (use-package semantic
    :init
    (require 'semantic/ia)
    (require 'semantic/wisent)
    (semantic-mode t)
    ;; Fixing a bug in semantic, see #22287
    (defun semanticdb-save-all-db-idle ()
      "Save all semantic tag databases from idle time.
Exit the save between databases if there is user input."
      (semantic-safe "Auto-DB Save: %S"
        ;; FIXME: Use `while-no-input'?
        (save-mark-and-excursion ;; <-- added line
         (semantic-exit-on-input 'semanticdb-idle-save
           (mapc (lambda (db)
                   (semantic-throw-on-input 'semanticdb-idle-save)
                   (semanticdb-save-db db t))
                 semanticdb-database-list)))))))

(add-hook 'c-mode-hook #'eos/setup-semantic-mode)
(add-hook 'java-mode-hook #'eos/setup-semantic-mode)
#+END_SRC

** Emacs' Built In Electric Modes (pair/indent/layout)
:PROPERTIES:
:CUSTOM_ID: electric-modes
:END:
Emacs finally has better support for automatically doing things like indentation
and pairing parentheses. So, let's enable (some) of that

First, stuff for automatically inserting pairs of characters:

#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
(setq electric-pair-preserve-balance t
      electric-pair-delete-adjacent-pairs t
      electric-pair-open-newline-between-pairs nil)
(show-paren-mode 1)
#+END_SRC

Now, how about some auto-indentation:

#+BEGIN_SRC emacs-lisp
(electric-indent-mode 1)

;; Ignore electric indentation for python and yaml
(defun electric-indent-ignore-mode (char)
  "Ignore electric indentation for python-mode"
  (if (or (equal major-mode 'python-mode)
          (equal major-mode 'yaml-mode))
      'no-indent
    nil))
(add-hook 'electric-indent-functions 'electric-indent-ignore-mode)
#+END_SRC

Finally, perhaps we want some automatic layout:

#+BEGIN_SRC emacs-lisp
(electric-layout-mode 1)
#+END_SRC


** Programming Mode Hooks
:PROPERTIES:
:CUSTOM_ID: prog-mode
:END:

In programming modes, make sure things like FIXME and TODO are
highlighted so they stand out:

#+BEGIN_SRC emacs-lisp
(defun eos/add-watchwords ()
  "Highlight FIXME, TODO, and NOCOMMIT in code TODO"
  (font-lock-add-keywords
   nil '(("\\<\\(FIXME:?\\|TODO:?\\|NOCOMMIT:?\\)\\>"
          1 '((:foreground "#d7a3ad") (:weight bold)) t))))

(add-hook 'prog-mode-hook #'eos/add-watchwords)
#+END_SRC

Also highlight the line in prog-mode:

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'hl-line-mode)
#+END_SRC
* Autocomplete with Company
:PROPERTIES:
:CUSTOM_ID: autocomplete
:END:

I use =company= for more than just programming completions (see ðŸ’•=company-emoji=ðŸ’•, f.e.), so let's
just enable it everywhere.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :ensure t
  :diminish company-mode
  ;; stupid flyspell steals the binding I really want, `C-.`
  :bind (("C-c ." . company-complete)
         ("C-." . company-complete))
  :init
  (add-hook 'after-init-hook #'global-company-mode)
  (use-package company-quickhelp
    :ensure t
    :init (add-hook 'company-mode-hook #'company-quickhelp-mode)
    :config (setq company-quickhelp-delay 2))
  :config
  (setq company-selection-wrap-around t
        ;; do or don't automatically start completion
        ;;company-idle-delay nil
        company-idle-delay 0.7
        company-minimum-prefix-length 4
        ;; don't downcase dabbrev suggestions
        company-dabbrev-downcase nil
        company-dabbrev-ignore-case nil
        company-dabbrev-code-ignore-case nil
        ;; sort completions by occurrence
        company-transformers '(company-sort-by-occurrence))
  (bind-keys :map company-active-map
             ("C-n" . company-select-next)
             ("C-p" . company-select-previous)
             ("C-d" . company-show-doc-buffer)
             ("C-l" . company-show-location)
             ("<tab>" . company-complete)))
#+END_SRC

Used smart-tab to complete everywhere except for ERC, shell and mu4e.

#+BEGIN_SRC emacs-lisp
(use-package smart-tab
  :ensure t
  :defer t
  :diminish ""
  :init (global-smart-tab-mode 1)
  :config
  (setq smart-tab-using-hippie-expand t)
  (add-to-list 'smart-tab-disabled-major-modes 'mu4e-compose-mode)
  (add-to-list 'smart-tab-disabled-major-modes 'erc-mode)
  (add-to-list 'smart-tab-disabled-major-modes 'shell-mode))
#+END_SRC

* Git Magit with Magit and friends
:PROPERTIES:
:CUSTOM_ID: magit
:END:
I use =C-x g= everywhere to go directly to Magit.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status))
  :init (add-hook 'magit-mode-hook 'hl-line-mode)
  :config
  (setq git-commit-summary-max-length 70)
  (setenv "GIT_PAGER" "")
  (if (file-exists-p  "/usr/local/bin/emacsclient")
      (setq magit-emacsclient-executable "/usr/local/bin/emacsclient")
    (setq magit-emacsclient-executable (executable-find "emacsclient")))
  (defun eos/magit-browse ()
    "Browse to the project's github URL, if available"
    (interactive)
    (let ((url (with-temp-buffer
                 (unless (zerop (call-process-shell-command
                                 "git remote -v" nil t))
                   (error "Failed: 'git remote -v'"))
                 (goto-char (point-min))
                 (when (re-search-forward
                        "github\\.com[:/]\\(.+?\\)\\.git" nil t)
                   (format "https://github.com/%s" (match-string 1))))))
      (unless url
        (error "Can't find repository URL"))
      (browse-url url)))

  (define-key magit-mode-map (kbd "C-c C-b") #'eos/magit-browse)
  ;; Magit has its own binding, so re-bind them
  (bind-key "M-1" #'eos/create-or-switch-to-eshell-1 magit-mode-map)
  (bind-key "M-2" #'eos/create-or-switch-to-eshell-2 magit-mode-map)
  (bind-key "M-3" #'eos/create-or-switch-to-eshell-3 magit-mode-map)
  (bind-key "M-4" #'eos/create-or-switch-to-eshell-4 magit-mode-map))
#+END_SRC

There's also a package called magit-gh-pulls that shows the pull requests when
viewing the magit buffer

#+BEGIN_SRC emacs-lisp
(use-package magit-gh-pulls
  :ensure t
  :init
  (add-hook 'magit-mode-hook #'turn-on-magit-gh-pulls)
  :config
  ;; work around https://github.com/sigma/magit-gh-pulls/issues/83
  (setq magit-gh-pulls-pull-detail-limit 50))
#+END_SRC

Quite useful, as well as the =C-x n= and =C-x p= bindings.

#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :ensure t
  :defer t
  :bind (("C-x P" . git-gutter:popup-hunk)
         ("C-x p" . git-gutter:previous-hunk)
         ("C-x n" . git-gutter:next-hunk)
         ("C-c G" . git-gutter:popup-hunk))
  :diminish ""
  :init
  (add-hook 'prog-mode-hook #'git-gutter-mode)
  (add-hook 'org-mode-hook #'git-gutter-mode))
#+END_SRC

Ediff is fantastic for looking through diffs

#+BEGIN_SRC emacs-lisp
(use-package ediff
  :config
  (progn
    (setq
     ;; Always split nicely for wide screens
     ediff-split-window-function 'split-window-horizontally)))
#+END_SRC

Finally, a nice helper to browse code whenever it remotely may be,
=browse-at-remote=

#+BEGIN_SRC emacs-lisp
(use-package browse-at-remote
  :ensure t
  :bind ("C-c g g" . browse-at-remote/browse))
#+END_SRC

* Flycheck - Syntax Checking On The Fly
:PROPERTIES:
:CUSTOM_ID: flycheck
:END:

Pretty minimally configured, but awesome tool for most dynamic languages.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :defer 5
  :bind (("M-g M-n" . flycheck-next-error)
         ("M-g M-p" . flycheck-previous-error)
         ("M-g M-=" . flycheck-list-errors))
  :init (global-flycheck-mode)
  :diminish flycheck-mode
  :config
  (progn
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc json-jsonlint json-python-json))
    (use-package flycheck-pos-tip
      :ensure t
      :init (flycheck-pos-tip-mode))
    (use-package helm-flycheck
      :ensure t
      :init (define-key flycheck-mode-map (kbd "C-c ! h") 'helm-flycheck))
    (use-package flycheck-haskell
      :ensure t
      :init (add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))))
#+END_SRC

* Elisp
:PROPERTIES:
:CUSTOM_ID: elisp
:END:
This contains the configuration for elisp programming

First, turn on paredit and eldoc everywhere it's useful:

#+BEGIN_SRC emacs-lisp
(use-package paredit
  :ensure t
  :commands paredit-mode
  :diminish "()"
  :init
  (add-hook 'emacs-lisp-mode-hook #'paredit-mode)
  (add-hook 'ielm-mode-hook #'paredit-mode)
  :config
  (bind-key "M-)" #'paredit-forward-slurp-sexp paredit-mode-map)
  (bind-key "C-(" #'paredit-forward-barf-sexp paredit-mode-map)
  (bind-key "C-)" #'paredit-forward-slurp-sexp paredit-mode-map)
  (bind-key ")" #'paredit-close-parenthesis paredit-mode-map)
  (bind-key "M-\"" #'my/other-window-backwards paredit-mode-map))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :diminish eldoc-mode
  :init
  (add-hook 'emacs-lisp-mode-hook #'eldoc-mode)
  (add-hook 'ielm-mode-hook #'eldoc-mode)
  :config
  (setq eldoc-idle-delay 0.3))
#+END_SRC

Define some niceties for popping up an ielm buffer:

#+BEGIN_SRC emacs-lisp
(defun ielm-other-window ()
  "Run ielm on other window"
  (interactive)
  (switch-to-buffer-other-window
   (get-buffer-create "*ielm*"))
  (call-interactively 'ielm))

(define-key emacs-lisp-mode-map (kbd "C-c C-z") 'ielm-other-window)
(define-key lisp-interaction-mode-map (kbd "C-c C-z") 'ielm-other-window)
#+END_SRC

Turn on elisp-slime-nav if available, so =M-.= works to jump to function
definitions:

#+BEGIN_SRC emacs-lisp
(use-package elisp-slime-nav
  :ensure t
  :diminish elisp-slime-nav-mode
  :init (add-hook 'emacs-lisp-mode-hook #'elisp-slime-nav-mode))
#+END_SRC

Borrowed from Steve Purcell's config. This pretty-prints the results.

#+begin_src emacs-lisp
(bind-key "M-:" #'pp-eval-expression)

(defun eos/eval-last-sexp-or-region (prefix)
 "Eval region from BEG to END if active, otherwise the last sexp."
 (interactive "P")
 (if (and (mark) (use-region-p))
 (eval-region (min (point) (mark)) (max (point) (mark)))
 (pp-eval-last-sexp prefix)))

(bind-key "C-x C-e" 'eos/eval-last-sexp-or-region emacs-lisp-mode-map)

(define-key lisp-mode-shared-map (kbd "RET") 'reindent-then-newline-and-indent)
#+end_src

There are some nice things we can install for development on Emacs itself,
things such as =debbugs=, which allows us to look at the bug database for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package debbugs
  :ensure t)
#+END_SRC

* Python
:PROPERTIES:
:CUSTOM_ID: python
:END:
Some various python settings, including loading jedi if needed to set up
keys, the custom hook only loads jedi when editing python files:

#+BEGIN_SRC emacs-lisp
(use-package python
  :defer t
  :config
  (define-key python-mode-map (kbd "<backtab>") 'python-back-indent))
#+END_SRC

I'm using the [[https://github.com/porterjamesj/virtualenvwrapper.el][virtualenvwrapper]] package for managing these

#+BEGIN_SRC emacs-lisp
(use-package virtualenvwrapper
  :ensure t
  :defer t
  :init
  (progn
    (venv-initialize-interactive-shells)
    (venv-initialize-eshell)
    (setq venv-location (or (getenv "WORKON_HOME")
                            "~/.venvs"))))
#+END_SRC


* Ruby
:PROPERTIES:
:CUSTOM_ID: ruby
:END:
Using rbenv, set it up correctly when idle

#+BEGIN_SRC emacs-lisp
(use-package rbenv
  :ensure t
  :defer 25
  :init
  ;; I don't really care about the active ruby in the modeline
  (setq rbenv-show-active-ruby-in-modeline nil)
  (global-rbenv-mode t))
#+END_SRC

* Haskell
:PROPERTIES:
:CUSTOM_ID: haskell
:END:
Use GHC for haskell mode, and turn on auto-complete and some doc/indent
modes:

#+BEGIN_SRC emacs-lisp
(defun eos/turn-off-flyspell ()
  (interactive)
  (flyspell-mode -1))

(use-package haskell-mode
  :ensure t
  :defer t
  :init
  (add-hook 'haskell-mode-hook #'haskell-indentation-mode)
  (add-hook 'haskell-mode-hook #'turn-on-haskell-doc-mode)
  (add-hook 'haskell-mode-hook #'subword-mode)
  (add-hook 'haskell-mode-hook #'interactive-haskell-mode)
  (add-hook 'haskell-mode-hook #'eos/turn-off-flyspell)
  :config
  (setq haskell-process-suggest-remove-import-lines t
        haskell-process-auto-import-loaded-modules t
        haskell-process-log t
        haskell-process-type 'auto)
  (define-key haskell-mode-map (kbd "C-c C-l") #'haskell-process-load-or-reload)
  (define-key haskell-mode-map (kbd "C-`") #'haskell-interactive-bring)
  (define-key haskell-mode-map (kbd "C-c t") #'haskell-process-do-type)
  (define-key haskell-mode-map (kbd "C-c C-i") #'haskell-process-do-info)
  ;;(define-key haskell-mode-map (kbd "C-c C-c") #'haskell-process-cabal-build)
  (define-key haskell-mode-map (kbd "C-c M-k") #'haskell-interactive-mode-clear)
  ;;(define-key haskell-mode-map (kbd "C-c c") #'haskell-process-cabal)
  (define-key haskell-mode-map (kbd "SPC") #'haskell-mode-contextual-space))
#+END_SRC

* Javascript
:PROPERTIES:
:CUSTOM_ID: javascript
:END:
I want indentation of 2 for json/js.

#+BEGIN_SRC emacs-lisp
(setq-default js-indent-level 2)
#+END_SRC

Bleh javascript. js2-mode is better than nothing.

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :mode "\\.js\\'"
  :config (js2-imenu-extras-setup))
#+END_SRC

There's =tern= also, but I leave it turned off by default, just installed

#+BEGIN_SRC emacs-lisp
(use-package tern
  :ensure t)
#+END_SRC
